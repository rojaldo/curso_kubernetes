<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Módulo 6: Configuración y Secrets</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/theme/white.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-light.min.css">
    <style>
        .reveal { text-align: left; color: #555555; }
        .reveal section { text-align: left; padding: 40px; display: flex; flex-direction: column; justify-content: flex-start; }
        .reveal h1, .reveal h2, .reveal h3 { text-transform: none; text-align: left; color: #1e88e5; }
        .reveal h1 { font-size: 2em; margin-bottom: 0.4em; }
        .reveal h2 { font-size: 1.4em; margin-bottom: 0.4em; }
        .reveal h3 { font-size: 1.1em; margin-bottom: 0.3em; color: #1e88e5; }
        .reveal p { font-size: 0.6em; margin: 0.2em 0; color: #555555; }
        .reveal strong { color: #1e88e5; font-weight: bold; }
        .reveal pre { background: #f8f8f8; border: 1px solid #ddd; width: 100%; padding: 0.4em; margin: 0.4em 0; font-size: 0.45em; }
        .reveal pre code { color: #333333; }
        .reveal code { background: #f0f0f0; padding: 0.2em 0.4em; border-radius: 3px; color: #d63384; font-size: 0.85em; }
        .reveal ul { font-size: 0.55em; text-align: left; margin-left: 0.5em; }
        .reveal li { margin: 0.2em 0; color: #555555; }
        .reveal table { font-size: 0.5em; width: 100%; border-collapse: collapse; margin: 0.4em 0; }
        .reveal table th, .reveal table td { border: 1px solid #ddd; padding: 0.1em; text-align: left; }
        .reveal table th { background-color: #f0f0f0; color: #1e88e5; font-weight: bold; }
        .highlight-box { background-color: #e3f2fd; border-left: 4px solid #1e88e5; padding: 0.4em; margin: 0.4em 0; font-size: 0.5em; }
        .warning-box { background-color: #fff3e0; border-left: 4px solid #f57c00; padding: 0.4em; margin: 0.4em 0; font-size: 0.5em; }
        .success-box { background-color: #e8f5e9; border-left: 4px solid #388e3c; padding: 0.4em; margin: 0.4em 0; font-size: 0.5em; }
        .two-column { display: flex; gap: 2em; }
        .two-column > div { flex: 1; }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">
            <!-- Portada -->
            <section>
                <h1>Módulo 6: Configuración y Secrets</h1>
                <h2 style="color: #1e88e5;">ConfigMaps, Secrets, Downward API y Gestión de Variables</h2>
                <p style="font-size: 0.7em; margin-top: 1em;">Separación de configuración, datos sensibles y metadatos en Kubernetes</p>
            </section>

            <!-- Introducción -->
            <section>
                <h2>¿Por qué separarar configuración del código?</h2>
                <ul>
                    <li><strong>12-Factor App:</strong> Configuración debe ser externa, no hardcodeada</li>
                    <li><strong>Múltiples ambientes:</strong> dev, staging, prod con diferentes parámetros</li>
                    <li><strong>Sin reconstruir imagen:</strong> Cambios de config sin rebuild de Docker</li>
                    <li><strong>Datos sensibles:</strong> Separar secretos de configuración normal</li>
                    <li><strong>Reutilización:</strong> Misma imagen en múltiples contextos</li>
                </ul>
            </section>

            <section>
                <h2>Comparativa: Kubernetes vs Docker</h2>
                <table>
                    <tr>
                        <th>Aspecto</th>
                        <th>Docker</th>
                        <th>Kubernetes</th>
                    </tr>
                    <tr>
                        <td><strong>Configuración</strong></td>
                        <td>En imagen, Dockerfile, .env</td>
                        <td>ConfigMaps, Secrets, Downward API</td>
                    </tr>
                    <tr>
                        <td><strong>Gestión</strong></td>
                        <td>Por contenedor</td>
                        <td>A nivel cluster, reutilizable</td>
                    </tr>
                    <tr>
                        <td><strong>Actualización</strong></td>
                        <td>Manual, requiere restart</td>
                        <td>Dinámico, rollout automático</td>
                    </tr>
                    <tr>
                        <td><strong>Escalabilidad</strong></td>
                        <td>Limitada</td>
                        <td>Config compartida entre pods</td>
                    </tr>
                </table>
            </section>

            <!-- ConfigMaps - Conceptos -->
            <section>
                <h2>¿Qué es un ConfigMap?</h2>
                <ul>
                    <li><strong>Objeto Kubernetes</strong> que almacena datos de configuración no confidencial</li>
                    <li><strong>Pares clave-valor</strong> en formato simple o archivos</li>
                    <li><strong>Máximo 1MB</strong> de datos por ConfigMap</li>
                    <li><strong>Inyectable</strong> como variables de entorno o volúmenes</li>
                    <li><strong>Reutilizable:</strong> Múltiples Pods pueden compartir</li>
                    <li><strong>Namespaced:</strong> Visibles solo en su namespace</li>
                </ul>
            </section>

            <section>
                <h2>Casos de Uso de ConfigMaps</h2>
                <ul>
                    <li><strong>Configuración de aplicación:</strong> URLs, puertos, timeouts</li>
                    <li><strong>Archivos de configuración:</strong> nginx.conf, application.properties, logging.yml</li>
                    <li><strong>Valores por ambiente:</strong> diferentes valores para dev/staging/prod</li>
                    <li><strong>Scripts de inicialización:</strong> shell scripts, entrypoints</li>
                    <li><strong>Datos de referencia:</strong> mapeos, tablas de búsqueda, listas</li>
                    <li><strong>Localizaciones:</strong> mensajes, traducciones, idiomas</li>
                </ul>
            </section>

            <section>
                <h2>¿Cuándo NO usar ConfigMaps?</h2>
                <ul>
                    <li><strong>Datos sensibles:</strong> credenciales, tokens, claves → <strong>Secrets</strong></li>
                    <li><strong>Datos grandes:</strong> más de 1MB de datos → persistencia externa</li>
                    <li><strong>Datos binarios:</strong> imágenes, ejecutables → PersistentVolumes</li>
                    <li><strong>Información muy dinámica:</strong> estado de aplicación → base de datos</li>
                    <li><strong>Datos de sistema:</strong> configuración del cluster → manifiestos</li>
                </ul>
                <div class="warning-box">
                    <strong>Límite duro:</strong> 1MB por ConfigMap incluyendo todas las claves
                </div>
            </section>

            <!-- ConfigMaps - Creación -->
            <section>
                <h2>Creación: Desde Literales</h2>
                <pre><code class="language-bash">kubectl create configmap app-config \
  --from-literal=database.host=localhost \
  --from-literal=database.port=5432 \
  --from-literal=app.name=myapp \
  --from-literal=app.version=1.0.0 \
  --from-literal=log.level=INFO</code></pre>
                <div class="highlight-box">
                    <strong>Ventaja:</strong> Rápido para valores simples, directo en línea
                </div>
            </section>

            <section>
                <h2>Creación: Desde Archivos</h2>
                <pre><code class="language-bash"># Crear archivos de configuración
echo "server.port=8080" > app.properties
echo "db.url=jdbc:mysql://localhost:3306/mydb" >> app.properties

# Crear ConfigMap desde archivo
kubectl create configmap app-config \
  --from-file=app.properties

# Desde directorio (crea una clave por archivo)
kubectl create configmap app-config \
  --from-file=./config/</code></pre>
            </section>

            <section>
                <h2>Creación: YAML Simple</h2>
                <pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: default
  labels:
    app: myapp
    version: v1
data:
  database.host: localhost
  database.port: "5432"
  database.name: mydb
  app.name: myapp
  app.version: "1.0.0"
  log.level: INFO</code></pre>
            </section>

            <section>
                <h2>Creación: YAML con Datos Multiline</h2>
                <pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  # Archivo de propiedades
  app.properties: |
    server.port=8080
    server.timeout=30000
    server.compression=gzip

  # Archivo nginx.conf
  nginx.conf: |
    server {
      listen 80;
      server_name _;
      location / {
        proxy_pass http://backend:8080;
        proxy_set_header Host $host;
      }
    }

  # Archivo logging
  logging.json: |
    {
      "level": "INFO",
      "format": "json"
    }</code></pre>
            </section>

            <section>
                <h2>Creación: ConfigMap Multi-archivo</h2>
                <pre><code class="language-bash"># Estructura de directorios
mkdir -p config/app
mkdir -p config/nginx

# Crear archivos
echo "server.port=8080" > config/app/app.properties
echo "log.level=DEBUG" >> config/app/app.properties
echo "listen 80;" > config/nginx/nginx.conf

# Crear ConfigMap desde directorio
kubectl create configmap web-config \
  --from-file=config/</code></pre>
                <p><strong>Resultado:</strong> Claves serán <code>app/app.properties</code> y <code>nginx/nginx.conf</code></p>
            </section>

            <!-- ConfigMaps - Consumo -->
            <section>
                <h2>Consumo: Variables de Entorno (Individual)</h2>
                <pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: app
spec:
  containers:
  - name: app
    image: myapp:latest
    env:
    - name: DB_HOST
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: database.host
    - name: DB_PORT
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: database.port</code></pre>
            </section>

            <section>
                <h2>Consumo: Inyección Bulk (envFrom)</h2>
                <pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: app
spec:
  containers:
  - name: app
    image: myapp:latest
    envFrom:
    - configMapRef:
        name: app-config
    - configMapRef:
        name: cache-config
        prefix: CACHE_</code></pre>
                <ul>
                    <li><strong>Automático:</strong> Todas las claves se convierten en variables</li>
                    <li><strong>database.host</strong> → <code>DATABASE_HOST</code> (guiones → underscores, mayúsculas)</li>
                    <li><strong>prefix:</strong> Prefija todas las variables generadas</li>
                </ul>
            </section>

            <section>
                <h2>Consumo: ConfigMap como Volumen</h2>
                <pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx:latest
    volumeMounts:
    - name: config
      mountPath: /etc/nginx/conf.d
      readOnly: true
  volumes:
  - name: config
    configMap:
      name: nginx-config
      items:
      - key: nginx.conf
        path: default.conf
        mode: 0644</code></pre>
            </section>

            <section>
                <h2>Consumo: Pasar como Argumentos</h2>
                <pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: app
spec:
  containers:
  - name: app
    image: myapp:latest
    args:
    - --database-host=$(DB_HOST)
    - --database-port=$(DB_PORT)
    - --log-level=$(LOG_LEVEL)
    env:
    - name: DB_HOST
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: database.host
    - name: DB_PORT
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: database.port
    - name: LOG_LEVEL
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: log.level</code></pre>
            </section>

            <section>
                <h2>Consumo: Montar Parcialmente</h2>
                <pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: app
spec:
  containers:
  - name: app
    image: myapp:latest
    volumeMounts:
    - name: config
      mountPath: /etc/config
  volumes:
  - name: config
    configMap:
      name: app-config
      items:
      # Solo estos archivos
      - key: app.properties
        path: app.properties
      - key: logging.properties
        path: logging.properties</code></pre>
            </section>

            <!-- ConfigMaps - Actualización -->
            <section>
                <h2>Actualización de ConfigMaps</h2>
                <pre><code class="language-bash"># Editar en kubectl
kubectl edit configmap app-config

# Patch con jq
kubectl patch configmap app-config \
  -p '{"data":{"database.port":"5433"}}'

# Reemplazar completamente
kubectl delete configmap app-config
kubectl create configmap app-config --from-file=config/</code></pre>
            </section>

            <section>
                <h2>Problema: Actualización Automática</h2>
                <div class="warning-box">
                    <strong>PROBLEMA:</strong> Pods existentes NO se actualizan automáticamente cuando cambia ConfigMap
                </div>
                <ul>
                    <li><strong>Env vars:</strong> Requieren reinicio del Pod para reflejar cambios</li>
                    <li><strong>Volúmenes:</strong> Se actualizan automáticamente en segundos</li>
                </ul>
            </section>

            <section>
                <h2>Soluciones para Propagación de Cambios</h2>
                <ul>
                    <li><strong>Opción 1 - Rollout Restart:</strong> <code>kubectl rollout restart deployment/app</code> (simple, causa downtime)</li>
                    <li><strong>Opción 2 - Usar Volúmenes:</strong> ConfigMaps como volúmenes se actualizan automáticamente (recomendado)</li>
                    <li><strong>Opción 3 - Reloader:</strong> Herramienta que monitorea cambios y reinicia Pods automáticamente</li>
                    <li><strong>Opción 4 - Configuración externa:</strong> Base de datos, consul, etcd con polling de aplicación</li>
                </ul>
                <div class="success-box">
                    <strong>Recomendado:</strong> Usar volúmenes para config dinámica, externa para cambios críticos
                </div>
            </section>

            <!-- Secrets - Conceptos -->
            <section>
                <h2>¿Qué es un Secret?</h2>
                <ul>
                    <li><strong>Similar a ConfigMap</strong> pero para datos sensibles</li>
                    <li><strong>Encriptación en reposo</strong> (opcional pero recomendado)</li>
                    <li><strong>Control RBAC</strong> más restrictivo por defecto</li>
                    <li><strong>Base64 codificados</strong> (NO es encriptación real)</li>
                    <li><strong>Montaje seguro</strong> con permisos automáticos (0600)</li>
                    <li><strong>Máximo 1MB</strong> de datos</li>
                </ul>
            </section>

            <section>
                <h2>Tipos de Secrets</h2>
                <table>
                    <tr>
                        <th>Tipo</th>
                        <th>Propósito</th>
                        <th>Contenido</th>
                    </tr>
                    <tr>
                        <td><strong>Opaque</strong></td>
                        <td>Datos genéricos</td>
                        <td>Cualquier base64</td>
                    </tr>
                    <tr>
                        <td><strong>kubernetes.io/service-account-token</strong></td>
                        <td>Token Service Account</td>
                        <td>Token JWT automático</td>
                    </tr>
                    <tr>
                        <td><strong>kubernetes.io/dockercfg</strong></td>
                        <td>Docker config (legacy)</td>
                        <td>.dockercfg</td>
                    </tr>
                    <tr>
                        <td><strong>kubernetes.io/dockerconfigjson</strong></td>
                        <td>Docker credenciales</td>
                        <td>config.json</td>
                    </tr>
                    <tr>
                        <td><strong>kubernetes.io/basic-auth</strong></td>
                        <td>Auth básica</td>
                        <td>username, password</td>
                    </tr>
                    <tr>
                        <td><strong>kubernetes.io/ssh-auth</strong></td>
                        <td>SSH keys</td>
                        <td>ssh-privatekey</td>
                    </tr>
                    <tr>
                        <td><strong>kubernetes.io/tls</strong></td>
                        <td>Certificados TLS</td>
                        <td>tls.crt, tls.key</td>
                    </tr>
                    <tr>
                        <td><strong>bootstrap.kubernetes.io/token</strong></td>
                        <td>Bootstrap token</td>
                        <td>Token de cluster</td>
                    </tr>
                </table>
            </section>

            <!-- Secrets - Creación -->
            <section>
                <h2>Creación: Desde Literales</h2>
                <pre><code class="language-bash">kubectl create secret generic db-credentials \
  --from-literal=username=admin \
  --from-literal=password=Sup3rS3cr3tP@ssw0rd</code></pre>
                <div class="highlight-box">
                    <strong>Tipo:</strong> <code>generic</code> equivale a tipo <code>Opaque</code>
                </div>
            </section>

            <section>
                <h2>Creación: Desde Archivos</h2>
                <pre><code class="language-bash"># Crear archivos con credentials
echo -n "admin" > username.txt
echo -n "Sup3rS3cr3tP@ssw0rd" > password.txt

# Crear Secret
kubectl create secret generic db-credentials \
  --from-file=username=username.txt \
  --from-file=password=password.txt

# Limpiar archivos locales
rm username.txt password.txt</code></pre>
                <div class="warning-box">
                    <strong>Importante:</strong> Usar <code>echo -n</code> para NO incluir salto de línea
                </div>
            </section>

            <section>
                <h2>Creación: YAML con Base64</h2>
                <pre><code class="language-bash"># Codificar valores en base64
echo -n "admin" | base64
# YWRtaW4=

echo -n "Sup3rS3cr3tP@ssw0rd" | base64
# U3VwM3JTM2NyM3RQQHNzdzByZA==</code></pre>
                <pre><code class="language-yaml">apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
type: Opaque
data:
  username: YWRtaW4=
  password: U3VwM3JTM2NyM3RQQHNzdzByZA==</code></pre>
            </section>

            <section>
                <h2>Creación: YAML con stringData (Recomendado)</h2>
                <pre><code class="language-yaml">apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
type: Opaque
stringData:
  # NO requiere base64 encoding
  username: admin
  password: Sup3rS3cr3tP@ssw0rd
  connection-string: "postgresql://admin:Sup3rS3cr3tP@ssw0rd@localhost:5432/mydb"</code></pre>
                <div class="success-box">
                    <strong>Mejor:</strong> <code>stringData</code> es más legible, Kubernetes codifica automáticamente
                </div>
            </section>

            <section>
                <h2>Creación: Secret TLS</h2>
                <pre><code class="language-bash"># Generar certificado autofirmado
openssl req -x509 -newkey rsa:4096 \
  -keyout tls.key -out tls.crt \
  -days 365 -nodes \
  -subj "/CN=myapp.com"

# Crear Secret TLS
kubectl create secret tls app-tls \
  --cert=tls.crt \
  --key=tls.key</code></pre>
            </section>

            <section>
                <h2>Creación: Docker Registry Secret</h2>
                <pre><code class="language-bash">kubectl create secret docker-registry regcred \
  --docker-server=docker.io \
  --docker-username=myuser \
  --docker-password=mypassword \
  --docker-email=myuser@example.com</code></pre>
                <pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: app
spec:
  imagePullSecrets:
  - name: regcred
  containers:
  - name: app
    image: private-registry.io/myapp:latest</code></pre>
            </section>

            <section>
                <h2>Creación: Basic Auth Secret</h2>
                <pre><code class="language-bash"># Generar credenciales base64
echo -n "myuser:mypassword" | base64
# bXl1c2VyOm15cGFzc3dvcmQ=

# Crear Secret
kubectl create secret generic basic-auth \
  --from-literal=auth=bXl1c2VyOm15cGFzc3dvcmQ=</code></pre>
            </section>

            <!-- Base64 vs Encriptación -->
            <section>
                <h2>Base64: Codificación vs Encriptación</h2>
                <div class="warning-box">
                    <strong>CRÍTICO:</strong> Base64 es CODIFICACIÓN, NO es ENCRIPTACIÓN
                </div>
                <pre><code class="language-bash"># Es trivial decodificar
echo -n "U3VwM3JTM2NyM3RQQHNzdzByZA==" | base64 -d
# Resultado: Sup3rS3cr3tP@ssw0rd

# Base64 es reversible en segundos
python3 -c "import base64; print(base64.b64decode('U3VwM3JTM2NyM3RQQHNzdzByZA==').decode())"</code></pre>
            </section>

            <section>
                <h2>Seguridad: Encriptación en Reposo</h2>
                <p><strong>Problema:</strong> Secrets en etcd están en base64, visible para administradores</p>
                <pre><code class="language-yaml">apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
  - secrets
  providers:
  - aescbc:
      keys:
      - name: key1
        secret: dGhpcyBpcyBhIDMyIGJ5dGUgc2VjcmV0IGtleQ==
  - identity: {}</code></pre>
                <div class="highlight-box">
                    <strong>Solución:</strong> Habilitar EncryptionConfiguration en API server para encripción real
                </div>
            </section>

            <!-- Secrets - Consumo -->
            <section>
                <h2>Consumo: Variables de Entorno</h2>
                <pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: app
spec:
  containers:
  - name: app
    image: myapp:latest
    env:
    - name: DB_USER
      valueFrom:
        secretKeyRef:
          name: db-credentials
          key: username
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: db-credentials
          key: password</code></pre>
            </section>

            <section>
                <h2>Consumo: Volumen (RECOMENDADO)</h2>
                <pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: app
spec:
  containers:
  - name: app
    image: myapp:latest
    volumeMounts:
    - name: secrets
      mountPath: /etc/secrets
      readOnly: true
  volumes:
  - name: secrets
    secret:
      secretName: db-credentials
      defaultMode: 0400</code></pre>
                <ul>
                    <li><strong>defaultMode: 0400:</strong> Permiso solo lectura para owner</li>
                    <li><strong>readOnly: true:</strong> Previene modificación accidental</li>
                    <li><strong>Mejor que env vars:</strong> No aparecen en logs con facilidad</li>
                </ul>
            </section>

            <section>
                <h2>Consumo: Volumen con Items Específicos</h2>
                <pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: app
spec:
  containers:
  - name: app
    image: myapp:latest
    volumeMounts:
    - name: secrets
      mountPath: /etc/secrets
      readOnly: true
  volumes:
  - name: secrets
    secret:
      secretName: db-credentials
      items:
      - key: username
        path: db-user.txt
        mode: 0400
      - key: password
        path: db-pass.txt
        mode: 0400</code></pre>
            </section>

            <!-- Downward API -->
            <section>
                <h2>Downward API: ¿Qué es?</h2>
                <ul>
                    <li><strong>Mecanismo de Kubernetes</strong> para exponer metadatos del Pod a contenedor</li>
                    <li><strong>Sin ConfigMaps ni Secrets:</strong> Información disponible automáticamente</li>
                    <li><strong>Información del Pod:</strong> nombre, namespace, labels, annotations</li>
                    <li><strong>Información de recursos:</strong> CPU/memory requests y limits</li>
                    <li><strong>Dinámico:</strong> Se actualiza sin reiniciar Pod</li>
                </ul>
            </section>

            <section>
                <h2>Downward API: Variables de Entorno</h2>
                <pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: app
  labels:
    app: myapp
    version: v1
spec:
  containers:
  - name: app
    image: myapp:latest
    env:
    - name: POD_NAME
      valueFrom:
        fieldRef:
          fieldPath: metadata.name
    - name: POD_NAMESPACE
      valueFrom:
        fieldRef:
          fieldPath: metadata.namespace
    - name: POD_IP
      valueFrom:
        fieldRef:
          fieldPath: status.podIP
    - name: NODE_NAME
      valueFrom:
        fieldRef:
          fieldPath: spec.nodeName</code></pre>
            </section>

            <section>
                <h2>Downward API: Labels y Annotations</h2>
                <pre><code class="language-yaml">    env:
    - name: POD_LABELS
      valueFrom:
        fieldRef:
          fieldPath: metadata.labels
    - name: APP_LABEL
      valueFrom:
        fieldRef:
          fieldPath: metadata.labels['app']
    - name: VERSION_ANNOTATION
      valueFrom:
        fieldRef:
          fieldPath: metadata.annotations['version']</code></pre>
            </section>

            <section>
                <h2>Downward API: Recursos (CPU/Memory)</h2>
                <pre><code class="language-yaml">    env:
    - name: MEMORY_LIMIT
      valueFrom:
        resourceFieldRef:
          containerName: app
          resource: limits.memory
    - name: MEMORY_REQUEST
      valueFrom:
        resourceFieldRef:
          containerName: app
          resource: requests.memory
    - name: CPU_REQUEST
      valueFrom:
        resourceFieldRef:
          containerName: app
          resource: requests.cpu
    - name: CPU_LIMIT
      valueFrom:
        resourceFieldRef:
          containerName: app
          resource: limits.cpu</code></pre>
            </section>

            <section>
                <h2>Downward API: Volumen con Metadatos</h2>
                <pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: app
  labels:
    app: myapp
    tier: frontend
  annotations:
    description: "My application"
    version: "1.0.0"
spec:
  containers:
  - name: app
    image: myapp:latest
    volumeMounts:
    - name: podinfo
      mountPath: /etc/podinfo
      readOnly: true
  volumes:
  - name: podinfo
    downwardAPI:
      items:
      - path: "name"
        fieldRef:
          fieldPath: metadata.name
      - path: "namespace"
        fieldRef:
          fieldPath: metadata.namespace
      - path: "labels"
        fieldRef:
          fieldPath: metadata.labels</code></pre>
            </section>

            <section>
                <h2>Downward API: Contenido Generado</h2>
                <pre><code class="language-bash"># Archivos creados en /etc/podinfo/
$ cat /etc/podinfo/name
app

$ cat /etc/podinfo/namespace
default

$ cat /etc/podinfo/labels
app="myapp"
tier="frontend"

$ cat /etc/podinfo/annotations
description="My application"
version="1.0.0"</code></pre>
            </section>

            <!-- EnvFrom -->
            <section>
                <h2>EnvFrom: Inyección Bulk de Múltiples Fuentes</h2>
                <pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: app
spec:
  containers:
  - name: app
    image: myapp:latest
    envFrom:
    - configMapRef:
        name: app-config
    - secretRef:
        name: db-credentials
    - configMapRef:
        name: cache-config
        prefix: CACHE_</code></pre>
                <ul>
                    <li><strong>Automático:</strong> Todas las claves se convierten en env vars</li>
                    <li><strong>Conversión:</strong> Puntos y guiones → underscores, MAYÚSCULAS</li>
                    <li><strong>prefix:</strong> Prefija todas las variables generadas</li>
                </ul>
            </section>

            <section>
                <h2>EnvFrom: Reglas de Conversión de Claves</h2>
                <table>
                    <tr>
                        <th>Clave Original</th>
                        <th>Variable Generada</th>
                        <th>Regla</th>
                    </tr>
                    <tr>
                        <td>database.host</td>
                        <td>DATABASE_HOST</td>
                        <td>Puntos → underscores</td>
                    </tr>
                    <tr>
                        <td>app-name</td>
                        <td>APP_NAME</td>
                        <td>Guiones → underscores</td>
                    </tr>
                    <tr>
                        <td>cache_size</td>
                        <td>CACHE_SIZE</td>
                        <td>Ya tiene underscore</td>
                    </tr>
                    <tr>
                        <td>LOG.LEVEL</td>
                        <td>LOG_LEVEL</td>
                        <td>Siempre mayúsculas</td>
                    </tr>
                </table>
            </section>

            <!-- Ejemplo Completo -->
            <section>
                <h2>Ejemplo Completo: Deployment con Config</h2>
                <pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  database.host: postgres
  database.port: "5432"
  app.log.level: INFO
---
apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
stringData:
  username: admin
  password: Sup3rS3cr3tP@ssw0rd
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: app
        image: myapp:latest
        envFrom:
        - configMapRef:
            name: app-config
        - secretRef:
            name: db-credentials
        volumeMounts:
        - name: config
          mountPath: /etc/config
          readOnly: true
      volumes:
      - name: config
        configMap:
          name: app-config</code></pre>
            </section>

            <!-- Best Practices -->
            <section>
                <h2>Best Practices: ConfigMaps</h2>
                <ul>
                    <li><strong>Separación por ambiente:</strong> app-config-dev, app-config-prod</li>
                    <li><strong>Versionado explícito:</strong> app-config-v1, app-config-v2 para rollbacks</li>
                    <li><strong>Labels descriptivos:</strong> environment, version, component</li>
                    <li><strong>Documentación:</strong> Propósito y valores esperados de cada clave</li>
                    <li><strong>Límite de tamaño:</strong> Máximo 1MB, distribuir si necesario</li>
                    <li><strong>Validación en app:</strong> Proporcionar defaults, validar formatos</li>
                </ul>
            </section>

            <section>
                <h2>Best Practices: Secrets (1/2)</h2>
                <ul>
                    <li><strong>Encriptación en reposo:</strong> Habilitar EncryptionConfiguration en API server</li>
                    <li><strong>RBAC estricto:</strong> Limitar acceso por rol y usuario</li>
                    <li><strong>Auditoría:</strong> Registrar acceso a secrets sensibles</li>
                    <li><strong>Rotación regular:</strong> Cambiar contraseñas y tokens cada 90 días</li>
                    <li><strong>No en git:</strong> Nunca commitar secrets sin encriptación</li>
                </ul>
            </section>

            <section>
                <h2>Best Practices: Secrets (2/2)</h2>
                <ul>
                    <li><strong>Volumen vs Env:</strong> Variables de entorno pueden filtrarse en logs/ps</li>
                    <li><strong>readOnly: true:</strong> Previene modificación accidental en Pod</li>
                    <li><strong>defaultMode: 0400:</strong> Permisos restrictivos automáticos</li>
                    <li><strong>External Secrets Operator:</strong> Sincronizar desde Vault, AWS Secrets Manager</li>
                    <li><strong>Sealed Secrets o Sops:</strong> Encriptar secrets antes de commitar</li>
                </ul>
            </section>

            <section>
                <h2>Best Practices: Organización</h2>
                <ul>
                    <li><strong>Separar por componente:</strong> app-config, db-config, cache-config diferentes</li>
                    <li><strong>Por namespace:</strong> ConfigMaps/Secrets aislados por namespace automáticamente</li>
                    <li><strong>Naming claro:</strong> Nombres que describan contenido y ambiente</li>
                    <li><strong>Labels organizadores:</strong> app, environment, component, version</li>
                    <li><strong>Documentar cambios:</strong> Historial de cambios de configuración crítica</li>
                </ul>
            </section>

            <section>
                <h2>Comparativa: Cuándo usar qué</h2>
                <table>
                    <tr>
                        <th>Método</th>
                        <th>Cuándo usar</th>
                        <th>Ventajas</th>
                        <th>Desventajas</th>
                    </tr>
                    <tr>
                        <td><strong>Env literal</strong></td>
                        <td>Valores constantes</td>
                        <td>Simple</td>
                        <td>No reutilizable</td>
                    </tr>
                    <tr>
                        <td><strong>ConfigMap env</strong></td>
                        <td>Config compartida</td>
                        <td>Reutilizable</td>
                        <td>No se actualiza automáticamente</td>
                    </tr>
                    <tr>
                        <td><strong>ConfigMap vol</strong></td>
                        <td>Archivos grandes</td>
                        <td>Actualización dinámica</td>
                        <td>Requiere polling en app</td>
                    </tr>
                    <tr>
                        <td><strong>Secret env</strong></td>
                        <td>Valores muy simples</td>
                        <td>Directo</td>
                        <td>Menos seguro que volumen</td>
                    </tr>
                    <tr>
                        <td><strong>Secret vol</strong></td>
                        <td>Datos sensibles</td>
                        <td>MÁS SEGURO, recomendado</td>
                        <td>Requiere parseo en app</td>
                    </tr>
                    <tr>
                        <td><strong>Downward API</strong></td>
                        <td>Metadatos del Pod</td>
                        <td>Dinámico, sin config</td>
                        <td>Solo metadatos</td>
                    </tr>
                </table>
            </section>

            <!-- Herramientas -->
            <section>
                <h2>Herramientas Complementarias</h2>
                <ul>
                    <li><strong>Sealed Secrets:</strong> Encripta secrets en git, desencripta en cluster</li>
                    <li><strong>Sops:</strong> Encriptación de archivos YAML antes de commitear</li>
                    <li><strong>HashiCorp Vault:</strong> Gestión centralizada y rotación automática</li>
                    <li><strong>AWS Secrets Manager:</strong> Secrets AWS integrados con K8s</li>
                    <li><strong>External Secrets Operator:</strong> Sincroniza secrets desde múltiples fuentes</li>
                    <li><strong>Reloader:</strong> Reinicia Pods cuando cambian ConfigMaps/Secrets</li>
                </ul>
            </section>

            <!-- Troubleshooting -->
            <section>
                <h2>Troubleshooting: ConfigMaps</h2>
                <ul>
                    <li><strong>Pod no ve variables:</strong> Verificar nombre del ConfigMap coincida, namespaces iguales</li>
                    <li><strong>Cambios no reflejados:</strong> ConfigMaps en env requieren <code>rollout restart</code></li>
                    <li><strong>Archivo no encontrado:</strong> Verificar <code>mountPath</code> y <code>key</code> correctos</li>
                    <li><strong>Contenido vacío:</strong> Verificar ConfigMap fue creado correctamente: <code>kubectl get cm app-config -o yaml</code></li>
                </ul>
            </section>

            <section>
                <h2>Troubleshooting: Secrets</h2>
                <ul>
                    <li><strong>Secret no montado:</strong> Verificar nombre exacto y existencia del Secret</li>
                    <li><strong>Permiso denegado:</strong> Verificar RBAC, token de service account</li>
                    <li><strong>Base64 incorrecto:</strong> Verificar encoding con <code>echo -n | base64</code></li>
                    <li><strong>Variable no definida:</strong> Verificar clave existe en Secret: <code>kubectl get secret -o yaml</code></li>
                </ul>
            </section>

            <!-- Verificación -->
            <section>
                <h2>Verificación: ConfigMaps</h2>
                <pre><code class="language-bash"># Listar todos los ConfigMaps
kubectl get configmaps -A

# Ver contenido completo
kubectl get configmap app-config -o yaml

# Ver solo las claves
kubectl get configmap app-config -o jsonpath='{.data}' | jq

# Editar en línea
kubectl edit configmap app-config

# Eliminar
kubectl delete configmap app-config</code></pre>
            </section>

            <section>
                <h2>Verificación: Secrets</h2>
                <pre><code class="language-bash"># Listar todos los Secrets
kubectl get secrets -A

# Ver estructura (sin valores)
kubectl describe secret db-credentials

# Ver valor decodificado
kubectl get secret db-credentials \
  -o jsonpath='{.data.password}' | base64 -d

# Ver todo en base64
kubectl get secret db-credentials -o yaml</code></pre>
            </section>

            <section>
                <h2>Debugging: Dentro del Pod</h2>
                <pre><code class="language-bash"># Ver variables de entorno
kubectl exec -it app -- env | grep DB_

# Listar volúmenes montados
kubectl exec -it app -- mount | grep config

# Ver contenido del volumen
kubectl exec -it app -- ls -la /etc/config/
kubectl exec -it app -- cat /etc/config/app.properties

# Verificar Secret montado
kubectl exec -it app -- cat /etc/secrets/password</code></pre>
            </section>

            <!-- Resumen -->
            <section>
                <h2>Resumen: ConfigMap vs Secret</h2>
                <table>
                    <tr>
                        <th>Aspecto</th>
                        <th>ConfigMap</th>
                        <th>Secret</th>
                    </tr>
                    <tr>
                        <td><strong>Propósito</strong></td>
                        <td>Config no sensible</td>
                        <td>Datos sensibles</td>
                    </tr>
                    <tr>
                        <td><strong>Tamaño máximo</strong></td>
                        <td>1MB</td>
                        <td>1MB</td>
                    </tr>
                    <tr>
                        <td><strong>Formato</strong></td>
                        <td>Texto plano</td>
                        <td>Base64 (decodificable)</td>
                    </tr>
                    <tr>
                        <td><strong>Encriptación</strong></td>
                        <td>No (visible en etcd)</td>
                        <td>Opcional (recomendado habilitarla)</td>
                    </tr>
                    <tr>
                        <td><strong>RBAC</strong></td>
                        <td>Estándar</td>
                        <td>Más restrictivo recomendado</td>
                    </tr>
                    <tr>
                        <td><strong>Tipos</strong></td>
                        <td>Un tipo</td>
                        <td>Múltiples tipos especializados</td>
                    </tr>
                    <tr>
                        <td><strong>Consumo</strong></td>
                        <td>Env, volumen, argumentos</td>
                        <td>Env, volumen, imagePullSecrets</td>
                    </tr>
                </table>
            </section>

            <section>
                <h2>Checklist: Antes de Producción</h2>
                <div class="highlight-box">
                    <strong>Configuración:</strong>
                    <ul>
                        <li>Separar config por ambiente (dev/staging/prod)</li>
                        <li>Documentar todas las variables requeridas</li>
                        <li>Establecer valores por defecto sensatos</li>
                        <li>Validar formato de valores en aplicación</li>
                    </ul>
                </div>
                <div class="warning-box">
                    <strong>Secrets:</strong>
                    <ul>
                        <li>Habilitar EncryptionConfiguration en etcd</li>
                        <li>Implementar rotación de secrets</li>
                        <li>Verificar RBAC restringido</li>
                        <li>Nunca commitar secrets sin encriptación</li>
                    </ul>
                </div>
            </section>

            <section>
                <h2>Checklist: Monitoreo y Mantenimiento</h2>
                <div class="success-box">
                    <strong>Auditoría:</strong>
                    <ul>
                        <li>Registrar acceso a secrets sensibles</li>
                        <li>Monitorear cambios de configuración</li>
                        <li>Alertas si modifican secrets en producción</li>
                        <li>Revisión periódica de RBAC</li>
                    </ul>
                </div>
                <div class="highlight-box">
                    <strong>Operaciones:</strong>
                    <ul>
                        <li>Mantener registro de cambios de config</li>
                        <li>Plan de rollback para cambios críticos</li>
                        <li>Testing de cambios en staging</li>
                        <li>Documentar cambios importantes</li>
                    </ul>
                </div>
            </section>

            <!-- FAQ -->
            <section>
                <h2>Preguntas Frecuentes: Configuración y Secrets</h2>
                <ul>
                    <li><strong>¿Es seguro base64 para secrets?</strong> No, es codificación, no encriptación. Habilita EncryptionConfiguration en API server.</li>
                    <li><strong>¿Se actualizan automáticamente los cambios de ConfigMap?</strong> Solo en volúmenes. En env vars requieren rollout restart.</li>
                    <li><strong>¿Puedo usar ConfigMap para datos sensibles?</strong> No, usa Secrets. ConfigMap está visible en etcd sin encripción.</li>
                    <li><strong>¿Cuál es la diferencia entre ConfigMapRef y secretRef?</strong> ConfigMapRef para datos no sensibles, secretRef para datos privados.</li>
                </ul>
            </section>

            <!-- EXERCISE 1 -->
            <section>
                <h2>Ejercicio 1: Crear y Usar ConfigMaps</h2>
                <p><strong>Objetivo:</strong> Crear ConfigMaps de diferentes formas e inyectarlos en Pods.</p>
                <ul>
                    <li>Crea un ConfigMap con --from-literal para variables simples</li>
                    <li>Crea un ConfigMap con --from-file para archivos de configuración</li>
                    <li>Crea un Pod que consume ConfigMap como variables de entorno</li>
                    <li>Crea otro Pod que monta el ConfigMap como volumen</li>
                    <li>Verifica que ambos acceden a la configuración correctamente</li>
                </ul>
                <div class="highlight-box">
                    <strong>Resultado esperado:</strong> ConfigMaps creados de múltiples formas, Pods accediendo correctamente
                </div>
            </section>

            <!-- EXERCISE 2 -->
            <section>
                <h2>Ejercicio 2: Creación Segura de Secrets</h2>
                <p><strong>Objetivo:</strong> Crear Secrets correctamente evitando exposición de datos.</p>
                <ul>
                    <li>Crea un Secret con credenciales usando stringData</li>
                    <li>Crea un Secret TLS con certificados autofirmados</li>
                    <li>Crea un Secret docker-registry para pulls privados</li>
                    <li>Verifica estructura con kubectl get secret -o yaml</li>
                    <li>Decodifica un valor con base64 para entender el formato</li>
                </ul>
                <div class="highlight-box">
                    <strong>Resultado esperado:</strong> Secrets creados, entiende estructura base64, no es encriptación
                </div>
            </section>

            <!-- EXERCISE 3 -->
            <section>
                <h2>Ejercicio 3: Consumo Seguro de Secrets</h2>
                <p><strong>Objetivo:</strong> Consumir Secrets de forma segura en Pods.</p>
                <ul>
                    <li>Crea un Pod que consume Secret como volumen (recomendado)</li>
                    <li>Crea un Pod que consume Secret como variables de entorno</li>
                    <li>Compara permisos: volumen es 0400, env vars visibles en ps</li>
                    <li>Verifica que readOnly: true previene modificación</li>
                    <li>¿Cuál es más seguro? ¿Por qué?</li>
                </ul>
                <div class="highlight-box">
                    <strong>Resultado esperado:</strong> Entiende diferencia entre métodos de consumo, sabe por qué volumen es mejor
                </div>
            </section>

            <!-- EXERCISE 4 -->
            <section>
                <h2>Ejercicio 4: Downward API y Metadatos</h2>
                <p><strong>Objetivo:</strong> Usar Downward API para acceder a metadatos del Pod.</p>
                <ul>
                    <li>Crea un Pod con Downward API en variables de entorno</li>
                    <li>Accede a: nombre, namespace, labels, annotations, CPU/memory</li>
                    <li>Crea un Pod con Downward API en volumen montado</li>
                    <li>Verifica contenido de archivos generados automáticamente</li>
                    <li>¿Cuándo es útil Downward API vs ConfigMap?</li>
                </ul>
                <div class="highlight-box">
                    <strong>Resultado esperado:</strong> Metadatos accesibles automáticamente, sin configuración manual
                </div>
            </section>

            <!-- EXERCISE 5 -->
            <section>
                <h2>Ejercicio 5: Deployment Completo con Config</h2>
                <p><strong>Objetivo:</strong> Desplegar aplicación con ConfigMap y Secret integrados.</p>
                <ul>
                    <li>Crea ConfigMap con configuración de aplicación</li>
                    <li>Crea Secret con credenciales de BD</li>
                    <li>Crea Deployment que usa ambos</li>
                    <li>Verifica con kubectl exec que variables y archivos están disponibles</li>
                    <li>Modifica ConfigMap, realiza rollout restart, verifica actualización</li>
                </ul>
                <div class="highlight-box">
                    <strong>Resultado esperado:</strong> Deployment completo con configuración y secrets, cambios se propagan
                </div>
            </section>

            <!-- RESOURCES -->
            <section>
                <h2>Recursos Recomendados</h2>
                <ul>
                    <li><strong>Documentación oficial:</strong> kubernetes.io/docs/concepts/configuration/</li>
                    <li><strong>ConfigMaps y Secrets:</strong> kubernetes.io/docs/concepts/configuration/configmap/ y secret/</li>
                    <li><strong>Downward API:</strong> kubernetes.io/docs/concepts/workloads/pods/downward-api/</li>
                    <li><strong>Herramientas:</strong> Sealed Secrets, Sops, HashiCorp Vault, External Secrets Operator</li>
                    <li><strong>Certificación CKA:</strong> Incluye preguntas sobre ConfigMaps, Secrets, Downward API</li>
                </ul>
            </section>

            <!-- RESUMEN FINAL -->
            <section>
                <h2>Resumen Final: Configuración y Secrets</h2>
                <ul>
                    <li><strong>ConfigMaps:</strong> Datos no sensibles, reutilizables, máximo 1MB</li>
                    <li><strong>Secrets:</strong> Datos sensibles, base64 (no encriptación real), RBAC restringido</li>
                    <li><strong>Downward API:</strong> Metadatos del Pod, dinámico, sin configuración extra</li>
                    <li><strong>Consumo:</strong> Env vars (simple, no dinámico) vs Volúmenes (dinámico, recomendado)</li>
                    <li><strong>Seguridad:</strong> Encriptación en reposo, RBAC, auditoría, rotación de secrets</li>
                    <li><strong>Herramientas:</strong> Sealed Secrets, Sops, Vault para gestión avanzada</li>
                </ul>
            </section>

            <!-- CLOSING -->
            <section>
                <h1>¿Preguntas?</h1>
                <p style="font-size: 0.9em; margin-top: 2em;">Módulo 6: Configuración y Secrets</p>
                <p style="font-size: 0.75em; margin-top: 1em;">Kubernetes - Gestión de ConfigMaps, Secrets, Downward API y variables de entorno</p>
            </section>

        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            center: false,
            transition: 'slide',
            width: 1200,
            height: 800,
            slideNumber: true,
            margin: 0.1,
            minScale: 0.2,
            maxScale: 2.0
        });
        hljs.highlightAll();
    </script>
</body>
</html>
